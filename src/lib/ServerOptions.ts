/*
Author: Ing. Luca Gian Scaringella
GitHub: LucaCode
Copyright(c) Ing. Luca Gian Scaringella
 */

import {AuthOptions} from "./AuthEngine";
import {
    RecognizedString,
    CompressOptions,
    DEDICATED_COMPRESSOR_3KB,
    DEDICATED_COMPRESSOR_4KB,
    DEDICATED_COMPRESSOR_8KB,
    DEDICATED_COMPRESSOR_16KB,
    DEDICATED_COMPRESSOR_32KB,
    DEDICATED_COMPRESSOR_64KB,
    DEDICATED_COMPRESSOR_128KB,
    DEDICATED_COMPRESSOR_256KB,
    SHARED_COMPRESSOR
} from "ziron-ws";

export const COMPRESSOR_TO_INTERNAL_COMPRESSOR: Record<Compressor,CompressOptions> = {
    [Compressor.SharedCompressor]: SHARED_COMPRESSOR,
    [Compressor.DedicatedCompressor3KB]: DEDICATED_COMPRESSOR_3KB,
    [Compressor.DedicatedCompressor4KB]: DEDICATED_COMPRESSOR_4KB,
    [Compressor.DedicatedCompressor8KB]: DEDICATED_COMPRESSOR_8KB,
    [Compressor.DedicatedCompressor16KB]: DEDICATED_COMPRESSOR_16KB,
    [Compressor.DedicatedCompressor32KB]: DEDICATED_COMPRESSOR_32KB,
    [Compressor.DedicatedCompressor64KB]: DEDICATED_COMPRESSOR_64KB,
    [Compressor.DedicatedCompressor128KB]: DEDICATED_COMPRESSOR_128KB,
    [Compressor.DedicatedCompressor256KB]: DEDICATED_COMPRESSOR_256KB
};

export const enum Compressor {
    /**
     * @description
     * Zero overhead memory compression.
     */
    SharedCompressor,
    /**
     * @description
     * A sliding dedicated compress window that requires 3 KB of memory per socket.
     */
    DedicatedCompressor3KB,
    /**
     * @description
     * A sliding dedicated compress window that requires 4 KB of memory per socket.
     */
    DedicatedCompressor4KB,
    /**
     * @description
     * A sliding dedicated compress window that requires 8 KB of memory per socket.
     */
    DedicatedCompressor8KB,
    /**
     * @description
     * A sliding dedicated compress window that requires 16 KB of memory per socket.
     */
    DedicatedCompressor16KB,
    /**
     * @description
     * A sliding dedicated compress window that requires 32 KB of memory per socket.
     */
    DedicatedCompressor32KB,
    /**
     * @description
     * A sliding dedicated compress window that requires 64 KB of memory per socket.
     */
    DedicatedCompressor64KB,
    /**
     * @description
     * A sliding dedicated compress window that requires 128 KB of memory per socket.
     */
    DedicatedCompressor128KB,
    /**
     * @description
     * A sliding dedicated compress window that requires 256 KB of memory per socket.
     */
    DedicatedCompressor256KB,
}

export interface CompressionOptions {
    /**
     * @description
     * Activates or deactivates compression.
     * @default true
     */
    active?: boolean;
    /**
     * @description
     * Defines the compressor used to compress messages.
     * @default DedicatedCompressor4KB
     */
    compressor?: Compressor;
    /**
     * @description
     * Defines if batch packets should always be compressed.
     * @default false
     */
    alwaysCompressBatches?: boolean;
    /**
     * @description
     * Specifies at which byte size binary packets should be compressed.
     * @default 104857
     */
    minBytes?: number;
    /**
     * @description
     * Specifies at which string length text packets should be compressed.
     * @default 20000
     */
    minLength?: number;
}

export interface TLSOptions {
    /**
     * @description
     * The file that contains the certificate.
     */
    certFile?: RecognizedString;
    /**
     * @description
     * The file that contains multiple trusted certificates
     * in PEM format concatenated together.
     */
    caFile?: RecognizedString;
    /**
     * @description
     * The file that contains the private key.
     */
    keyFile?: RecognizedString;
    /**
     * @description
     * When the private key file is encrypted and protected with a passphrase,
     * it is necessary to provide it to decrypt the key file before usage.
     */
    passphrase?: RecognizedString;
    /**
     * @description
     * File name containing the Diffie-Hellman
     * (DH) key exchange parameters.
     */
    dhParamsFile?: RecognizedString;
    /**
     * @description
     * In this mode, the read buffers or write buffers memory for a
     * given SSL will be released when we no longer need them.
     * That mode can save around 34k per idle SSL connection and
     * has no effect on SSL v2 connections or DTLS connections.
     */
    releaseBuffersMode?: boolean;
}

export default interface ServerOptions {
    /**
     * @description
     * The id of the server.
     * It's essential when joining a cluster.
     * Notice when using the server in a cluster the id must be unique for every server.
     * When using the default generated id, you should not have any problems.
     * @default
     * Auto-generated by using the package: "uniqid".
     */
    id?: string;
    /**
     * @description
     * The port where the server should listen.
     * @default 3000
     */
    port?: number;
    /**
     * @description
     * The URL path of the server where handshake requests are processed, and the health endpoint is provided.
     * Notice multiple slashes at the end are not supported and will be removed.
     * @default '/'
     */
    path?: string;
    /**
     * @description
     * With this property, you can specify what origins are allowed to connect to the server.
     * You can specify the port and hostname.
     * Also, a star can be used as a wild card for any port or any hostname.
     * @example
     * //allow all origins
     * origins: null, or
     * origins: '*:*',
     *
     * //allow all with hostname example.de
     * origins: 'example.de:*', or
     * origins: 'example.de'
     *
     * //allow all with port 80
     * origins: '*:80'
     *
     * //allow only hostname example.de on port 80
     * origins: 'example.de:80'
     *
     * //allow all with hostname example.de or example2.de
     * origins: ['example.de:*','example2.de']
     *
     * @default null (all allowed)
     */
    origins?: string[] | string | null;
    /**
     * @description
     * Specifies the auth options that are used to sign and verify JSON web tokens.
     */
    auth?: AuthOptions & {
        /**
         * @description
         * The interval when the server checks the for expired auth tokens.
         * @default 12000ms
         */
        expireCheckInterval?: number,
    },
    /**
     * @description
     * Specifies whether the server should use permessage-deflate and
     * when to compress messages, and what compressor should be used.
     * @default {
     *     active: true,
     *     compressor: DedicatedCompressor4KB,
     *     alwaysCompressBatches: false,
     *     minBytes: 104857,
     *     minLength: 20000
     * }
     */
    compression?: CompressionOptions;
    /**
     * @description
     * Specifies if the client is allowed to publish into channels.
     * The PublishIn middleware will still be used to check access.
     * @default true
     */
    allowClientPublish?: boolean,
    /**
     * @description
     * Defines if the publisher in a channel should get its own publish.
     * The publisher is automatically determined if a client publishes,
     * but the publisher needs to be specified when using the exchange instance.
     * When the publisher is not specified, the published data will be
     * sent to all subscribers (also the publisher if the publisher is a subscriber).
     * @default true
     */
    publishToPublisher?: boolean,
    /**
     * @description
     * Specifies the limit of channels a socket can subscribe.
     * Null means unlimited.
     * @default 1000
     */
    socketChannelLimit?: number | null,
    /**
     * @description
     * Defines the default timeout in milliseconds for
     * receiving the response of an invoke.
     * The timeout only starts when the data of the invoke is completely transmitted,
     * and all containing streams are closed.
     * Notice that an individual response timeout can be specified for
     * an invoke that overrides this option value.
     * @default 7000
     */
    responseTimeout?: number,
    /**
     * @description
     * Specifies the interval in that the server pings the client sockets.
     * The client sockets need to send a pong before the next ping
     * is sent otherwise the socket will be disconnected.
     * @default 8000
     */
    pingInterval?: number,
    /**
     * @description
     * Specifies the maximum allowed message size in bytes.
     * The specified value also influences the max
     * batch size of text and binary packages.
     * @default 4194304 (4 MB)
     */
    maxPayloadSize?: number,
    /**
     * @description
     * The maximum send backpressure per socket that is allowed.
     * When the limit is exceeded, the socket connection will be dropped.
     * Notice that streams will be paused when the backpressure is more
     * than 50% of the maximum backpressure.
     * They continue automatically when the backpressure drains.
     * Also, the batching buffer max size depends on the value.
     * When the batching buffer exceeds 70% of the maximum backpressure,
     * the buffer will be automatically flushed.
     * @default 6291456 (6 MB)
     */
    maxBackpressure?: number,
    /**
     * @description
     * Specifies if the server should automatically provide a health HTTP endpoint.
     * The endpoint could be used for Docker health checks.
     * @default true
     */
    healthEndpoint?: boolean;
    /**
     * @description
     * Defines TLS options.
     * Provide these options to enable TLS 1.3 messaging encryption.
     * @default null
     */
    tls?: TLSOptions | null;
    /**
     * @description
     * Advanced option.
     * Defines the timeout in milliseconds for receiving
     * the referenced binary content packet of a text packet.
     * @default 10000
     */
    binaryContentPacketTimeout?: number;
    /**
     * @description
     * Advanced option.
     * This option defines how many
     * streams are allowed in a package.
     * @default 20
     */
    streamsPerPackageLimit?: number;
    /**
     * @description
     * Advanced option.
     * This option species if chunks
     * of streams can contain streams.
     * @default false
     */
    chunksCanContainStreams?: boolean;
}